#ifndef DCT_FACE_LPM_TABLES_HPP
#define DCT_FACE_LPM_TABLES_HPP
#pragma once
/*
 * Longest-Prefix-Match lookup tables implementing NDN Face Interest/Data semantics.
 *
 * Consists of: RIT - Registered Interest Table - LPM (Longest Prefix Match)
 *              PIT - Pending Interest Table - LPM or Exact-Match
 *              DIT - Duplicate Interest Table - Exact-Match
 *
 * Copyright (C) 2021-2 Pollere LLC
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation; either version 2.1 of
 *  the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, see <https://www.gnu.org/licenses/>.
 *  You may contact Pollere LLC at info@pollere.net.
 *
 *  This is not intended as production code.
 */

#include <map>
#include <set>
#include <type_traits>
#include <unordered_set>

#include "api.hpp"
#include "lpm.hpp"
#include "murmurHash3.hpp"  // for hasher mhashView

namespace dct {

/**
 * The Registered Interest Table (RIT) delivers incoming Interests to a
 * handler that may be able to satisfy them (respond with an appropriate
 * Data). The handler registers a prefix to match against incoming Interests
 * and a callback that's called with each matching Interest. RIT entries
 * persist until explicitly deleted.
 *
 * Since the key is a view (an rPrefix) its backing data needs to be preserved.
 * It can't go in the entry because the map item is built as a pair with the
 * prefix first so the name is copied to the heap with a pointer in the entry.
 */
struct RITentry {
    InterestCb iCb_;
    DataCb dCb_;
    std::vector<uint8_t>* name_;    // The 'prefix' is supplied as an rName since that's needed for the callback.
                                    // Its backing data is copied to the heap with a pointer here.

    RITentry(const rName& n, InterestCb&& iCb, DataCb&& dCb) : iCb_{std::move(iCb)}, dCb_{std::move(dCb)},
        name_{new std::vector<uint8_t>{n.m_blk.begin(), n.m_blk.end()}} { }
};

struct RIT : lpmLT<rPrefix, RITentry> {
    void add(RITentry&& e) { lpmLT<rPrefix, RITentry>::add(rPrefix{*e.name_}, std::move(e)); }
};

/**
 * The Duplicate Interest Table (DIT) keeps track of recently seen Interests
 * to filter out duplicates created by mis-behaving multicast implementations
 * and from the lack of any useful duplicate suppression in NFD. It uses the
 * fact that each Interest carries a randomly generated nonce so Interests
 * with the same name from different sources can be distinguished. The DIT
 * hashes each arriving Interest and compares it to a set recent hashes. If
 * the hash is not in the set it's accepted and added to the set. Otherwise
 * it's discarded.
 */
struct DIT : std::unordered_set<size_t> {
    std::unordered_set<size_t> ihash_{};

    auto hash(const rInterest& i) const noexcept { return std::hash<tlvParser>{}(i); }

    void add(size_t h) {
        // if too many entries, remove a random one
        if (ihash_.size() >= 256) {
            auto it = ihash_.begin();
            for (int b = h & 0xff; b-- > 0; it++) { }
            ihash_.erase(it);
        }
        ihash_.emplace(h);
    }
    void add(const rInterest& i) { add(hash(i)); }

    auto dupInterest(const rInterest& i) { auto h = hash(i); return std::pair(ihash_.contains(h), h); }
};

/**
 * The Pending Interest Table (PIT) records each outgoing Interest (one sent by the app)
 * together with a handler to call if an incoming Data satisfies the Interest (i.e., the
 * Interest's name is a prefix of the Data's name).
 *
 * There is also a PIT entry for each RIT-matching incoming Interest which allows any
 * matching Data generated by the RIT handler to be sent to the network.
 *
 * PIT entrys are deleted when satisfied by a Data or when they time out.
 *
 * All Interests and Datas are matched against the PIT. The lookup key is a hash of
 * the interest name.
 */
struct PITentry {
    using TOptr = std::unique_ptr<Timer>;

    std::unique_ptr<std::vector<uint8_t>> idat_{}; // bytes of the interest (backing store for prefix & interest_)
    rInterest i_{};
    InterestTO ito_{};      // Interest time-out callback (also indicates interest locally expressed)
    TOptr timer_{};         // Interest lifetime timer
    size_t onNet_{0};
    bool fromNet_{false};   // Interest was heard from net

    PITentry(const rInterest& i, InterestTO&& ito) :
                idat_{std::make_unique<std::vector<uint8_t>>(i.m_blk.begin(), i.m_blk.end())}, i_{*idat_},
                ito_{std::move(ito)} { }

    PITentry(const rInterest& i) :
                idat_{std::make_unique<std::vector<uint8_t>>(i.m_blk.begin(), i.m_blk.end())}, i_{*idat_},
                fromNet_{true} { }

    auto& timer() const noexcept { return timer_; }

    auto& timer(TOptr&& t) {
        timer_ = std::move(t);
        return *this;
    }
};

struct PIT : std::unordered_map<csID_t, PITentry> {
    using base = std::unordered_map<csID_t, PITentry>;
    using base::unordered_map;
    bool found(iterator it) const noexcept { return it != end(); }
    bool found(const_iterator it) const noexcept { return it != end(); }
    const_iterator find(const csID_t ih) const noexcept { return base::find(ih); }
    iterator find(const csID_t ih) noexcept { return base::find(ih); }
    auto find(rName&& n) noexcept { return find(mhashView(n)); }
    auto find(const rName& n) noexcept { return find(mhashView(n)); }

    auto erase(iterator it) { base::erase(it); }
    auto erase(csID_t ih) { base::erase(ih); }
    auto erase(const rInterest& i) { return base::erase(mhashView(i.name())); }

    // Interest Time-Out callback
    // if itCB is false, don't call the pit entry interest time out (which could send a new interest)
    // The PIT entry needs to be deleted and, since the callback might want to reinstate it,
    // the entry has to be removed before the callback
    void itoCB(rInterest i) {
        auto ih = mhashView(i.name());
        auto pi = find(ih);
        if (! found(pi)) return;
        auto ito = pi->second.ito_;
        erase(pi);
        if (ito) ito(ih);
    }

    /**
     * add a pit entry to the PIT. 
     *
     * The entry has to contain a copy of the Interest which may be large (e.g. Sync Interests
     * names contain an iblt of O(128) bytes) so we want to minimize copying. 
     */
    auto add(PITentry&& e) { return try_emplace(mhashView(e.i_.name()), std::move(e)); }

    /**
     * add Interest to PIT.
     *
     * If the entry doesn't exist it's created.
     *
     * If the entry exists (because it came in from the net or it was previously expressed
     * locally and hasn't timed out yet) a new entry is not created but the timeout of the
     * existing entry is updated and the new interest origin is recorded.
     *
     * returns 'true' if entry added (interest packet should be sent on) and false otherwise.
     */

    // add locally generated interest to PIT
    auto add(const rInterest& i, InterestTO&& ito) {
        if (auto it = find(mhashView(i.name())); found(it)) {
            auto& pe = it->second;
            pe.ito_ = std::move(ito);
            return std::pair<iterator,bool>{it, false};
        }
        return add(PITentry{i, std::move(ito)});
    }

    // add network generated interest to PIT
    auto add(const rInterest& i) {
        if (auto it = find(mhashView(i.name())); found(it)) {
            it->second.fromNet_ = true;
            it->second.onNet_++;
            return std::pair<iterator,bool>{it, false};
        }
        return add(PITentry{i});
    }
};

} // namespace dct

#endif  // DCT_FACE_LPM_TABLES_HPP
