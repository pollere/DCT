#ifndef DCT_FACE_LPM_TABLES_HPP
#define DCT_FACE_LPM_TABLES_HPP
#pragma once
/*
 * Longest-Prefix-Match lookup tables implementing DeftT's Face cState/cAdd semantics.
 *
 * Consists of: RST - Registered State Table - LPM (Longest Prefix Match)
 *              PST - Pending State Table - LPM or Exact-Match
 *              DST - Duplicate State Table - Exact-Match
 *
 * Copyright (C) 2021-4 Pollere LLC
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation; either version 2.1 of
 *  the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, see <https://www.gnu.org/licenses/>.
 *  You may contact Pollere LLC at info@pollere.net.
 *
 *  This is not intended as production code.
 */

#include <map>
#include <set>
#include <type_traits>
#include <unordered_set>

#include "api.hpp"
#include "lpm.hpp"
#include "murmurHash3.hpp"  // for hasher mhashView

namespace dct {

/**
 * The Registered State Table (RST) delivers incoming cStates to a
 * handler that may be able to satisfy them (respond with an appropriate
 * Data). The handler registers a prefix to match against incoming cStates
 * and a callback that's called with each matching cState. RST entries
 * persist until explicitly deleted.
 *
 * Since the key is a view (an rPrefix) its backing data needs to be preserved.
 * It can't go in the entry because the map item is built as a pair with the
 * prefix first so the name is copied to the heap with a pointer in the entry.
 */
struct RSTentry {
    StateCb sCb_;
    DataCb dCb_;
    std::vector<uint8_t>* name_;    // The 'prefix' is supplied as an rName since that's needed for the callback.
                                    // Its backing data is copied to the heap with a pointer here.

    RSTentry(const rName& n, StateCb&& sCb, DataCb&& dCb) : sCb_{std::move(sCb)}, dCb_{std::move(dCb)},
        name_{new std::vector<uint8_t>{n.m_blk.begin(), n.m_blk.end()}} { }
};

struct RST : lpmLT<rPrefix, RSTentry> {
    void add(RSTentry&& e) { lpmLT<rPrefix, RSTentry>::add(rPrefix{*e.name_}, std::move(e)); }
};

/**
 * The Duplicate State Table (DST) keeps track of recently seen cStates
 * to filter out duplicates created by mis-behaving multicast implementations.
 * It uses the fact that each cState carries a randomly generated nonce so cStates
 * with the same name from different sources can be distinguished. The DState
 * hashes each arriving cState and compares it to a set recent hashes. If
 * the hash is not in the set it's accepted and added to the set. Otherwise
 * it's discarded.
 */
struct DST : std::unordered_set<size_t> {
    std::unordered_set<size_t> shash_{};

    auto hash(const rState& s) const noexcept { return std::hash<tlvParser>{}(s); }

    void add(size_t h) {
        // if too many entries, remove a random one
        if (shash_.size() >= 256) {
            auto it = shash_.begin();
            for (int b = h & 0xff; b-- > 0; it++) { }
            shash_.erase(it);
        }
        shash_.emplace(h);
    }
    void add(const rState& s) { add(hash(s)); }

    auto dupState(const rState& s) { auto h = hash(s); return std::pair(shash_.contains(h), h); }
};

/**
 * The Pending State Table (PST) records each outgoing cState (one sent by the app)
 * together with a handler to call if an incoming cAdd satisfies the cState (i.e., the
 * cState's name is a prefix of the cAdd's name).
 *
 * There is also a PST entry for each RST-matching incoming cState which allows any
 * matching Data generated by the RST handler to be sent to the network.
 *
 * PST entrys are deleted when satisfied by a Data or when they time out.
 *
 * All cStates and cAdds are matched against the PST. The lookup key is a hash of
 * the cState name.
 */
struct PSTentry {
    using TOptr = std::unique_ptr<Timer>;

    std::unique_ptr<std::vector<uint8_t>> sdat_{}; // bytes of the cState (backing store for prefix & state_)
    rState s_{};
    StateTO sto_{};         // cState time-out callback (also indicates cState locally expressed)
    TOptr timer_{};         // cState lifetime timer
    size_t onNet_{0};
    bool fromNet_{false};   // cState was heard from net
    size_t used_{0};

    PSTentry(const rState& s, StateTO&& sto) :
                sdat_{std::make_unique<std::vector<uint8_t>>(s.m_blk.begin(), s.m_blk.end())}, s_{*sdat_},
                sto_{std::move(sto)} { }

    PSTentry(const rState& s) :
                sdat_{std::make_unique<std::vector<uint8_t>>(s.m_blk.begin(), s.m_blk.end())}, s_{*sdat_},
                fromNet_{true} { }

    auto& timer() const noexcept { return timer_; }

    auto& timer(TOptr&& t) {
        timer_ = std::move(t);
        return *this;
    }
};

struct PST : std::unordered_map<csID_t, PSTentry> {
    using base = std::unordered_map<csID_t, PSTentry>;
    using base::unordered_map;
    bool found(iterator it) const noexcept { return it != end(); }
    bool found(const_iterator it) const noexcept { return it != end(); }
    const_iterator find(const csID_t sh) const noexcept { return base::find(sh); }
    iterator find(const csID_t sh) noexcept { return base::find(sh); }
    auto find(rName&& n) noexcept { return find(mhashView(n)); }
    auto find(const rName& n) noexcept { return find(mhashView(n)); }

    auto erase(iterator it) { base::erase(it); }
    auto erase(csID_t sh) { base::erase(sh); }
    auto erase(const rState& s) { return base::erase(mhashView(s.name())); }

    // cState Time-Out callback
    // if stCB is false, don't call the pst entry cState time out (which could send a new cState)
    // The PST entry needs to be deleted and, since the callback might want to reinstate it,
    // the entry has to be removed before the callback
    void stoCB(rState s) {
        auto sh = mhashView(s.name());
        auto ps = find(sh);
        if (! found(ps)) return;
        auto sto = ps->second.sto_;
        erase(ps);
        if (sto) sto(sh);
    }

    /**
     * add a pst entry to the PST. 
     *
     * The entry has to contain a copy of the cState which may be large (e.g. Sync cState
     * names contain an iblt of O(128) bytes) so we want to minimize copying. 
     */
    auto add(PSTentry&& e) { return try_emplace(mhashView(e.s_.name()), std::move(e)); }
    auto add(csID_t hash, PSTentry&& e) { return try_emplace(hash, std::move(e)); }

    /**
     * add cState to PST.
     *
     * If the entry doesn't exist it's created.
     *
     * If the entry exists (because it came in from the net or it was previously expressed
     * locally and hasn't timed out yet) a new entry is not created but the timeout of the
     * existing entry is updated and the new cState origin is recorded.
     *
     * returns 'true' if entry added (cState packet should be sent on) and false otherwise.
     */

    // add locally generated cState to PST
    auto add(const rState& s, StateTO&& sto) {
        auto hash = mhashView(s.name());
        if (auto it = find(hash); found(it)) {
            auto& pe = it->second;
            pe.sto_ = std::move(sto);
            return std::pair<iterator,bool>{it, false};
        }
        return add(hash, PSTentry{s, std::move(sto)});
    }

    // add network generated cState to PST
    auto add(const rState& s) {
        auto hash = mhashView(s.name());
        if (auto it = find(mhashView(s.name())); found(it)) {
            it->second.fromNet_ = true;
            it->second.onNet_++;
            return std::pair<iterator,bool>{it, false};
        }
        return add(hash, PSTentry{s});
    }
};

} // namespace dct

#endif  // DCT_FACE_LPM_TABLES_HPP
